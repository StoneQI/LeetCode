18.4Sum

Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b*+ *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`.

**Note:**

The solution set must not contain duplicate quadruplets.

**Example:**

```
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

**题意**：找到四个数，其和等于target，且序列不重复

**我的解法**：52ms，9MB 。时间复杂度：$\ O(n^3)$ ，空间复杂度：$\ O(1)$

设置是个指标，同时固定第一个和最后一个，变动中间两个指标即可。

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        if (nums.size() < 3) return result; //处理边界情况
        sort(nums.begin(),nums.end());
        auto last = prev(nums.end());
        //先固定a，依次变动其他的指针
        for (auto a=nums.begin(); a<last-2; a++) {
            
            if (a>nums.begin() &&  *a == *prev(a)) {
                    continue; //重复的只处理一次
            }
            //在固定d，即最后一个指针，变动b、c指针
            for (auto d=last; d>a+2; d--) {
                auto b=next(a);//next 1 postion
                auto c=prev(d);//prev 1 postion
                if (d<last &&  *d == *next(d)) {
                    continue; //重复的只处理一次
                }
                while(b<c) {
                    int current = *a + *b + *c+*d;
                    if (current< target) b++; //小于target b增加
                    else if (current > target) c--; //大于target c减少
                    else {          
                        result.push_back({*a,*b,*c,*d});
                        while (b<c && *b==*(next(b))) b++;//when break,b != 
                        while (b<c && *c==*(prev(c))) c--;
                        b++; //因为b==prev(b)，prev(b)已经判断了，所以++
                        c--;   
                    }
                }
            }            
        }    
        return result;
    }
};
```

**论坛解法**：4ms, 43MB。时间复杂度：$\ O(n^3)$ ，空间复杂度：$\ O(1)$

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
		ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
		int len = nums.length;
		if (nums == null || len < 4)
			return res;

		Arrays.sort(nums);

		int max = nums[len - 1];
    	//判断别介条件
		if (4 * nums[0] > target || 4 * max < target)
			return res;

		int i, z;
		for (i = 0; i < len; i++) {
			z = nums[i];
			if (i > 0 && z == nums[i - 1])// 避免重复计算i
				continue;
			if (z + 3 * max < target) // 保证z不能太小，
				continue;
			if (4 * z > target) // 此时i后面的都不满足条件，直接退出
				break;
			if (4 * z == target) { //如果四个相同的*i和等于target，则后面的也都不满足，直接返回
				if (i + 3 < len && nums[i + 3] == z)
					res.add(Arrays.asList(z, z, z, z));
				break;
			}
			//分解为3Sum的问题，求i+1 到len-1中3个数和为target-z的 序列
			threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);
		}

		return res;
	}

	/*
	 * Find all possible distinguished three numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, the three numbers))
	 */
	public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1) {
		if (low + 1 >= high)
			return;

		int max = nums[high];
		if (3 * nums[low] > target || 3 * max < target)
			return;

		int i, z;
		for (i = low; i < high - 1; i++) {
			z = nums[i];
			if (i > low && z == nums[i - 1]) // avoid duplicate
				continue;
			if (z + 2 * max < target) // z is too small
				continue;

			if (3 * z > target) // z is too large
				break;

			if (3 * z == target) { // z is the boundary
				if (i + 1 < high && nums[i + 2] == z)
					fourSumList.add(Arrays.asList(z1, z, z, z));
				break;
			}

			twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);
		}

	}

	/*
	 * Find all possible distinguished two numbers adding up to the target
	 * in sorted array nums[] between indices low and high. If there are,
	 * add all of them into the ArrayList fourSumList, using
	 * fourSumList.add(Arrays.asList(z1, z2, the two numbers))
	 */
	public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,
			int z1, int z2) {

		if (low >= high)
			return;

		if (2 * nums[low] > target || 2 * nums[high] < target)
			return;

		int i = low, j = high, sum, x;
		while (i < j) {
			sum = nums[i] + nums[j];
			if (sum == target) {
				fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));

				x = nums[i];
				while (++i < j && x == nums[i]) // avoid duplicate
					;
				x = nums[j];
				while (i < --j && x == nums[j]) // avoid duplicate
					;
			}
			if (sum < target)
				i++;
			if (sum > target)
				j--;
		}
		return;
	}
```
