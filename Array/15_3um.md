15.3Sum

Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

```c++
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

**题意**：给定n个数，找出不重复的三个数，相加和为0。

**论坛解法**：时间复杂度：$\ O(n^2)$ ，空间复杂度：$\ O(1)$

首先对vector序列排序，然后设置三个指标，一个指向首元素`i`，一个指向首元素后一个元素`j`，一个指向尾元素`k`,然后固定`i`，移动`j`和`k`，如果sum小于0，则需要增加sum，使其靠近`0`，有由于序列有序，只需找到`j`后一个值，即增加了sum。sum大于0同理。一次遍历完后,增加`i`值，继续遍历。最后对满足的序列去重即可。

```C++
class Solution {
public:
    vector< vector<int> > result;

    vector< vector<int> > threeSum(vector<int>& nums) {

        if(nums.size() < 3) return result;

        map<vector<int>,int> mymap;

        sort(nums.begin(),nums.end());
		//固定i，依次调整j和k
        for(int i = 0;i < nums.size()-2;i++){
            if (i > 0 && (nums[i] == nums[i-1])) { //当出现重复时，只在第一次出现时计算一次
                continue;
            }
            int j = i+1;  //
            int k = nums.size()-1;
            //依次全部遍历
            while(j < k ){
                if(nums[i]+nums[j]+nums[k] < 0){ //如果和小于零，说明需要增大和，数列有序，因此j增加
                    j++;
                }else
                if(nums[i]+nums[j]+nums[k] > 0){ //如果和大于零，说明需要减小和，数列有序，因此k减小
                    k--;
                }
                else{
                    vector<int> temp;
                    temp.push_back(nums[i]);
                    temp.push_back(nums[j]);
                    temp.push_back(nums[k]);
                    mymap[temp] = 1; //map对vector<int>去重，即hash去重
                    j++;
                    k--;
                }
            }
        }
        for(auto t:mymap){
            result.push_back(t.first);
        }
        return result;
    }
};
```



**优化版本1**：108ms 18.3mb, 时间复杂度：$\ O(n^2)$ ，空间复杂度：$\ O(1)$

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        
        vector<vector<int>> result;
        if (nums.size() < 3) return result; //处理边界情况
        sort(nums.begin(),nums.end());
        const int target = 0;
        auto last=nums.end(); 
        //固定a，依次改变b和c
        //重点解释为什么没有去重算法。
        //首先是a，当固定a时，对于后面的值，根据b和c，对于相加为0的重复的值都只计算了一次，所以在固定a的这一次计算产生的多个3个数序列是不会有重复的，其中a和b可能会相同（仅当a为相同元素的第一个时），b和c不可能相同。再来讨论a，a只计算[begin,0],而且对于其中的所有元素，只计算一次，因此a也不会重复，最终得到的序列不会有任何一个重复的序列。
        for (auto a=nums.begin(); a<prev(last,2); a++) {
            auto b=next(a);//next 1 postion
            auto c=prev(last);//prev 1 postion
            
            if (a>nums.begin() &&  *a == *prev(a)) continue; //重复的只处理一次
            
            if (*a>0) return result; //当*a>0时说明，后面相加已经不可能等于0
            
            //注意下面的三个分支，当和不为0时，每个元素都处理了，即使相同元素也进行了。当和为0，这时的a、b、c已经组成一个序列，因此不可能，b、c一个不变，一个变的情况下和还能为0，因此去除a，b重复的现象。也就结下来组成的序列不可能再重复。
            while(b<c) {
                if (*a + *b + *c < target) b++; //小于0 b增加
                else if (*a + *b + *c > target) c--; //大于0 c减少
                else {          
                    result.push_back({*a,*b,*c});
                    while (b<c && *b==*(next(b))) b++;//when break,b != next(b),but b==prev(b). 对b和c去重复判断情况
                    while (b<c && *c==*(prev(c))) c--;
                    b++; //因为b==prev(b)，prev(b)已经判断了，所以++
                    c--;   
                }                     
            } 
        }    
        return result;
        
    }
};
```

**优化版本2**：

```c++
class Solution {
public:
    vector< vector<int> > result;

    vector< vector<int> > threeSum(vector<int>& nums) {

        if(nums.size() < 3) return result;


        sort(nums.begin(),nums.end());
        int i = 0;
        //固定i，一次改变j和k
        while(i < nums.size()-2){
            if (nums[i]>0) break;////当*i>0时说明，后面相加已经不可能等于0

            int j = i+1;
            int k = nums.size()-1;
            
            while(j < k ){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==0){ //符合条件添加到vector
                    vector<int> temp;
                    temp.push_back(nums[i]);
                    temp.push_back(nums[j]);
                    temp.push_back(nums[k]);
                    result.push_back(temp);
                    
                }
                
                //这里有三种情况，列如[-2,-1,-1,0,1,2,2],如果找到的第一个sum=0的为[-2,0,2]，此时j、k必须同时改变到不等于0、2的数，不然只改一个的话不会满足条件。所以同时满足两个if。当sum小于0，需要找到和j不相等的下一个值，因此只执行第一个条件。大于同理。
                
                //如果小于等于零，向后找到下一个不同的值
                if(sum <= 0){
                    while (  nums[j]==nums[++j]&& j<k) ;//当*j和*(++j)*不相等时，由于++j，所以此时j指向不等于j的后一个值
                }
                //如果大于等于零，向前找到下一个不同的值
                if(sum >= 0){
                     while ( nums[k--]==nums[k]&& j<k) ;//当*(k--)和*(k)*不相等时，由于k--，所以此时k指向不等于k的前一个值。注意这个比教的是 后一个k的值==前一个k的值。
                }
                
            }
            //保证每个i只处理一次
            while(nums[i] == nums[++i] && i < nums.size() - 2);
        }
        return result;
    }
};
```
